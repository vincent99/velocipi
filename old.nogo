package main

import (
	"context"
	"fmt"
	"time"

	"velocity/hardware/airsensor"
	"velocity/hardware/brightness"
	"velocity/hardware/expander"
	"velocity/hardware/lightsensor"
	"velocity/hardware/tpms"

	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// App struct
type App struct {
	ctx      context.Context
	light    *lightsensor.LightSensor
	bright   *brightness.Brightness
	air      *airsensor.AirSensor
	expander *expander.Expander

	stopTick chan bool
}

// NewApp creates a new App application struct
func NewApp() *App {
	return &App{}
}

// startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) startup(ctx context.Context) {
	fmt.Println("Startup")
	a.ctx = ctx
}

func (a *App) ready(ctx context.Context) {
	fmt.Println("Ready")
	ticker := time.NewTicker(1 * time.Second)

	_, err := tpms.Listen(func(t *tpms.Tire) {
		runtime.EventsEmit(ctx, "tire", t)
	})

	if err != nil {
		fmt.Println("Failed to init TPMS", err)
	}

	// wave3, err := wave.New()
	// if err != nil {
	// 	fmt.Println("Failed to init EcoFlow Wave", err)
	// }

	// err = wave3.Connect()
	// if err != nil {
	// 	fmt.Println("Failed to find EcoFlow Wave", err)
	// }

	light, err := lightsensor.NewLightSensor()
	if err != nil {
		fmt.Println("Failed to find light sensor", err)
	}
	a.light = light

	bright, err := brightness.NewBrightness(&brightness.Config{
		Sensor:        light,
		Speed:         500,
		MinBrightness: 45,
		MinLux:        2,  // Minimum brightness below this many lux
		MaxLux:        50, // Maximum brightness above this many
	})

	bright.Listen(func(b *brightness.Brightness, val brightness.Result) {
		runtime.EventsEmit(ctx, "brightness", val)
	})

	if err != nil {
		fmt.Println("Failed to find brightness control", err)
	}
	a.bright = bright

	air, err := airsensor.NewAirSensor()
	if err != nil {
		fmt.Println("Failed to find air sensor", err)
	}

	a.air = air

	expander, err := expander.NewExpander()
	a.expander = expander

	expanderEvent, expanderQuit := expander.Watch()

	quit := make(chan bool)
	a.stopTick = quit

	go func() {
		for {
			select {
			case data := <-expanderEvent:
				knob := data & 0b00011111
				joy := data >> 8

				// PortA: 7 6 5 4 3 2 1 0
				// Knob:  x L x O E I E P
				//          |   ||| ||| \- Push
				//          |   ||| \\\--- Inner Encoder
				//          |   \\\------- Outer Encoder
				//          \------------- LED (Output)
				knobBtn := knob&0x01 > 0
				knobInner := int((knob & 0b110) >> 1)
				knobOuter := int((knob & 0b11000) >> 3)

				// PortB: 7 6 5 4 3 2 1 0
				//   Joy: x E E R L D U P
				//          ||| | | | | \- Push
				//          ||| | | | \--- Up
				//          ||| | | \----- Down
				//          ||| | \------- Left
				//          ||| \--------- Right
				//          \\\----------- Encoder
				joyBtn := joy&0b1 == 1
				joyKnob := int((joy & 0b01100000) >> 5)
				joyDir := " "
				if joy&0b10 > 0 {
					joyDir = "D"
				} else if joy&0b100 > 0 {
					joyDir = "U"
				} else if joy&0b1000 > 0 {
					joyDir = "R"
				} else if joy&0b10000 > 0 {
					joyDir = "L"
				}

				fmt.Printf("Knob: %t %d %d (%08b), Joy: %t %s %d (%08b)\n", knobBtn, knobInner, knobOuter, knob, joyBtn, joyDir, joyKnob, joy)
				expander.Write(0x0040)
				time.Sleep(20 * time.Millisecond)
				expander.Write(0x0000)

			case <-ticker.C:
				t := time.Now()
				runtime.EventsEmit(ctx, "ticker", t)

				reading, err := a.air.Read()
				if err == nil {
					fmt.Printf("Air: %s", reading)
					runtime.EventsEmit(ctx, "air", reading)
				}
			case <-quit:
				ticker.Stop()
				expanderQuit <- true
				return
			}
		}
	}()

}

func (a *App) unload(ctx context.Context) (prevent bool) {
	fmt.Println("Unloading")
	a.stopTick <- true
	return false
}

func (a *App) shutdown(ctx context.Context) {
	fmt.Println("Shutdown")
}

func (a *App) ReadBrightness() brightness.Result {
	val := a.bright.Read()
	return val
}
